{\rtf1\ansi\deff0
{\fonttbl{\f0\froman Times New Roman;}{\f1\fmodern Courier New;}}
{\colortbl;\red0\green0\blue0;\red100\green100\blue100;}

\paperw12240\paperh15840\margl1440\margr1440\margt1440\margb1440

\pard\qc\b\fs56 City Explorer\b0\fs24\par
\par
\fs32 A Client-Server Application for City Information\fs24\par
\par
\par
\par
\b Module:\b0  Service-Oriented Computing (IT41073)\par
\b Assignment:\b0  Mini Project\par
\par
\par
\par
\par
\b Name:\b0  Chamod Ravishanka\par
\b Student ID:\b0  [Your Student ID]\par
\par
\par
\par
\par
December 2025\par

\page

\pard\b\fs28 1. Introduction\b0\fs24\par
\par
City Explorer is a web application I built to help users find information about cities around the world. The idea came from wanting to create something practical that combines multiple data sources into one easy-to-use interface. When you search for a city, you get weather data, country details, and geographic information all in one place instead of having to visit different websites.\par
\par
The application follows a client-server model. The frontend is a simple website built with HTML, CSS, and JavaScript. The backend runs on Node.js with Express handling the server logic. For storing search history, I used MongoDB. The whole thing connects to three external APIs to pull in the actual city data.\par
\par
What makes this project interesting from a service-oriented perspective is how it aggregates data from multiple sources. The GeoDB Cities API provides the basic city search functionality. OpenWeatherMap gives us current weather conditions. RestCountries fills in details about the country like population, currency, and languages. On the security side, I implemented Google OAuth for user login and API key validation for protecting the endpoints.\par
\par

\b\fs28 2. System Architecture\b0\fs24\par
\par
I designed the system with clear separation between the client and server components. Here's a diagram showing how everything connects:\par
\par
\pard\qc\cf2\i [INSERT ARCHITECTURE DIAGRAM SCREENSHOT HERE]\i0\cf1\par
\pard\par
The frontend is purely static files - HTML for structure, CSS for styling, and JavaScript for making API calls. When a user searches for a city, the JavaScript code sends a fetch request to our Express server. The server then makes the actual calls to the external APIs, processes the responses, and sends back a combined result.\par
\par
I chose this approach rather than calling the external APIs directly from the browser for a couple reasons. First, it keeps our API keys secure on the server. Second, it lets us combine data from multiple sources before sending it to the user. Third, we can add caching or rate limiting at the server level if needed.\par
\par
MongoDB stores the search records. Each record includes the city name, what country it's in, the weather at the time of search, and when the search happened. Users can view their history and delete old records.\par
\par

\b\fs28 3. External APIs\b0\fs24\par
\par
\b\fs24 GeoDB Cities API\b0\par
\par
This is the main API for city searches. It's available through RapidAPI and returns detailed information about cities worldwide. When you search for "London" for example, it gives you coordinates, population, region, and the country code. I use the country code to then fetch additional details from RestCountries.\par
\par
The endpoint I'm using is:\par
\par
\f1\fs20 GET https://wft-geo-db.p.rapidapi.com/v1/geo/cities?namePrefix=\{cityName\}\f0\fs24\par
\par
One thing to note is there's a rate limit on the free tier, so I had to be careful about not making too many requests during testing.\par
\par
\b OpenWeatherMap API\b0\par
\par
For weather data, OpenWeatherMap is pretty much the standard. Their free tier is generous enough for a project like this. I pass in the city coordinates from GeoDB and get back current temperature, humidity, wind speed, and a description of conditions.\par
\par
\f1\fs20 GET https://api.openweathermap.org/data/2.5/weather?lat=\{lat\}&lon=\{lon\}&appid=\{key\}&units=metric\f0\fs24\par
\par
The units=metric parameter means temperatures come back in Celsius, which is what most people expect.\par
\par
\b RestCountries API\b0\par
\par
This one doesn't require authentication, which is nice. I use it to get country-level information like the flag, capital city, population, currencies they use, and what languages are spoken. It fills in the context around the city data.\par
\par
\f1\fs20 GET https://restcountries.com/v3.1/alpha/\{countryCode\}\f0\fs24\par
\par

\b\fs28 4. Security Implementation\b0\fs24\par
\par
\b OAuth 2.0 with Google\b0\par
\par
For user authentication, I went with Google OAuth through Passport.js. It's what users expect these days - click "Sign in with Google" and you're done. No need to create yet another account and password.\par
\par
The flow works like this: user clicks login, gets redirected to Google, approves access, Google sends them back to our callback URL with an authorization code, Passport exchanges that for user info, and we create a session. The session is stored server-side and the user gets a cookie to maintain their logged-in state.\par
\par
Here's the basic Passport setup:\par
\par
\f1\fs18 passport.use(new GoogleStrategy(\{\par
    clientID: process.env.GOOGLE_CLIENT_ID,\par
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,\par
    callbackURL: '/auth/google/callback'\par
\}, (accessToken, refreshToken, profile, done) => \{\par
    return done(null, profile);\par
\}));\f0\fs24\par
\par
\b API Key Validation\b0\par
\par
Besides OAuth, I also implemented API key validation for the backend endpoints. This is the kind of security you'd use for server-to-server communication or if you wanted to let other developers build on top of your API.\par
\par
Every request to protected endpoints needs an x-api-key header. The middleware checks if it matches our stored key before letting the request through:\par
\par
\f1\fs18 const validateApiKey = (req, res, next) => \{\par
    const apiKey = req.headers['x-api-key'];\par
    if (apiKey && apiKey === process.env.API_KEY) \{\par
        next();\par
    \} else \{\par
        res.status(401).json(\{ error: 'Invalid API key' \});\par
    \}\par
\};\f0\fs24\par
\par
This gives us two layers of security - user-level auth through Google and application-level auth through API keys.\par
\par

\b\fs28 5. Application Screenshots\b0\fs24\par
\par
\b Main Search Interface\b0\par
\par
\pard\qc\cf2\i [INSERT SCREENSHOT OF HOME PAGE WITH SEARCH]\i0\cf1\par
\pard\par
The home page has a clean design with a search bar at the top. Users can type in any city name and hit search. The results show up below with all the aggregated information.\par
\par
\b City Search Results\b0\par
\par
\pard\qc\cf2\i [INSERT SCREENSHOT OF SEARCH RESULTS]\i0\cf1\par
\pard\par
When you search for a city, you see a card with the city name, country flag, current weather with an icon, temperature, and other details. There's a save button to add it to your history.\par
\par
\b Search History\b0\par
\par
\pard\qc\cf2\i [INSERT SCREENSHOT OF RECORDS/HISTORY PAGE]\i0\cf1\par
\pard\par
The records page shows all saved searches. Each entry has a delete button. This data is stored in MongoDB and persists between sessions.\par
\par

\b\fs28 6. Technical Challenges\b0\fs24\par
\par
The trickiest part was coordinating the multiple API calls. When someone searches for a city, I need to first hit GeoDB, then use those results to call both OpenWeatherMap and RestCountries. I used Promise.all to run the weather and country requests in parallel since they don't depend on each other:\par
\par
\f1\fs18 const [weatherData, countryData] = await Promise.all([\par
    fetchWeather(lat, lon),\par
    fetchCountry(countryCode)\par
]);\f0\fs24\par
\par
Error handling was another challenge. What if GeoDB returns results but the weather API is down? I had to make sure the app degrades gracefully and still shows whatever data is available.\par
\par
CORS was also something I had to deal with. The browser blocks cross-origin requests by default, so I added the cors middleware to Express with appropriate configuration.\par
\par

\b\fs28 7. Conclusion\b0\fs24\par
\par
Building City Explorer taught me a lot about how modern web services work together. The project demonstrates key SOC concepts: consuming external APIs, implementing authentication standards like OAuth, securing endpoints with API keys, and aggregating data from multiple sources into a unified interface.\par
\par
If I had more time, I'd add features like caching API responses to reduce external calls, user preferences for temperature units, and maybe a favorites system separate from the search history. Overall though, the application works well and shows how service-oriented architecture enables building useful applications by combining existing services.\par
\par

\b\fs28 8. References\b0\fs24\par
\par
\pard{\pntext\f0 \bullet\tab}{\*\pn\pnlvlblt\pnf0\pnindent360{\pntxtb\bullet}}\fi-360\li720 GeoDB Cities API - RapidAPI Documentation\par
{\pntext\f0 \bullet\tab}OpenWeatherMap API Documentation\par
{\pntext\f0 \bullet\tab}RestCountries API Documentation\par
{\pntext\f0 \bullet\tab}Passport.js Google OAuth Strategy Guide\par
{\pntext\f0 \bullet\tab}Express.js Official Documentation\par
{\pntext\f0 \bullet\tab}MongoDB Node.js Driver Documentation\par
\pard\par

}
